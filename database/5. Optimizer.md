# 옵티마이저
옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당한다. 옵티마이저는 크게 두 가지로 나눌 수 있다.

**규칙 기반 최적화**

- 대상 **테이블의 레코드 건수나 선택도 등을 고려하지 않고 Optimizer에 내장된 우선순위에 따라 실행 계획을 수립**
- 통계 정보를 참조하지 않기 때문에 같은 쿼리에 대해서 같은 실행 계획을 만든다.
- 초기 버전의 오라클 DBMS에서 많이 사용했다.
- 사용자의 데이터는 분포도가 매우 다양하기 때문에 현재로써는 많은 DBMS에서 사용하지 않는다.

**비용 기반 최적화**

- **쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 통계 정보를 이용해서 각 실행 계획의 비용을 산출**한다.
- 산출된 정보를 이용해서 가장 적은 비용이 드는 실행 계획을 선택해서 쿼리를 실행한다.
- 현재는 대부분의 RDBMS가 채택하고 있으며, MySQL 역시 마찬가지다.

# 기본 데이터 처리

옵티마이저는 인덱스를 사용하지 않는 풀 테이블 스캔을 할 수도 있고, 인덱스를 사용해서 데이터를 조회할 수도 있다.

**MySQL 옵티마이저는 다음의 조건에 해당할 때 주로 풀 테이블 스캔을 선택한다.**

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
- WHERE 절이나 ON 절에 인덱스를 이요할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔(Range Scan)을 할 수 있어도 조건에 일치하는 레코드가 너무 많은 경우

대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.

많은 사람들이 MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각한다. 하지만 이는 MyISAM 스토리지 엔진에는 맞는 이야기지만 InnoDB에서는 틀린 말이다.

InnoDB 스토리지 엔진에서는 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 **리드 어헤드(Read ahead)**가 자동으로 실행된다. 리드 어헤드는 앞으로 어떤 영역의 데이터가 필요할 지 예측해서 요청이 오기 전에 미리 디스크에 실어서 InnoDB의 버퍼 풀에 가져다 두는 것을 말한다.

즉, InnoDB에서 데이터를 조회할 때 **처음 몇 개의 데이터 페이지는 포그라운드 스레드(Foreground thread)가 페이지를 읽어오지만 특정 시점부터는 읽기 작업을 백그라운드 스레드가 실행한다.** 백그라운드 스레드는 한 번에 4개 또는 8개씩 페이지를 읽다가 단위를 증가시키고 최대 64개의 페이지를 읽어온다. **포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.**

MySQL 서버에서는 `innodb_read_ahead_threshold`시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할 지 임계값을 설정할 수 있다.  Default로 사용해도 상관없지만 MySQL를 데이터 웨어하우스로 사용하고 있다면 해당 옵션을 더 낮게 설정하는 것이 좋다.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다. **풀 인덱스 스캔**은 **실제 데이터가 아니라 인덱스를 처음부터 끝까지 스캔하는 것**을 말한다. 아래의 쿼리를 예로 보자.

```sql
SELECT Count(*)FROM employees;
```

쿼리는 employyes의 레코드 건수를 조회하므로 풀 테이블 스캔을 할 것처럼 보인다. 하지만 **옵티마이저는 풀 인덱스 스캔을 선택할 가능성이 높다.** 왜냐하면 **테이블 데이터보다 인덱스가 용량이 작기 때문**에 인덱스만 조회하면 훨씬 빠른 처리가 가능하기 때문이다.

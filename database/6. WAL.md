# WAL
DB에 저장되는 데이터는 하드 디스크에 저장된다.

디스크를 읽는 방식으로는 ```Sequential Access``` 와 ```Random Access``` 두 가지 방식이 있다.

데이터를 읽기 위해선 디스크 헤드가 움직이는 속도의 영향을 받는데,  ```Sequential Access```가 ```Random Access```에 비해 약 100배가 빠르다고 한다.

본론으로 돌아와, DBMS는 데이터를 어떤 형태로 저장하는가?

DBMS는 디스크에 데이터를 저장할 때, 블록 형태로 쪼개 디스크에 데이터를 쓰게되는데, commit을 한다고 바로 데이터베이스 서버에 있는 디스크 데이터를 하드에 저장하지 않는다.

대부분의 DB는 메모리나 Sequential한 log에 이를 보관하고, 적정 사이즈가 되면 이를 ```block``` 형태로 만들어 하드 디스크에 동기화한다.

왜 바로 block 형태로 만들지 않을까? 에 대한 답은 디스크 IO에 의한 성능 저하 때문이다.

Sequential 형태로 데이터를 처리하게 되면 리소스 소모 및 디스크 헤더의 움직임을 최소화함으로써 성능적 이점을 얻을 수 있다.

![image](https://github.com/jekyllPark/back-to-basic/assets/114489012/e485d663-8247-43d9-b956-4b9ca5216aca)

또한 Log를 활용함으로써 어떤 클라이언트가 데이터를 조회할지라도 동일한 데이터를 반환하여 일관성을 보장할 수 있고,

서버에 문제가 생기더라고 Log를 통해 원자성 또한 보장을 할 수 있다.


## **동작 원리:**
1. **트랜잭션 시작:** 새로운 트랜잭션이 시작되면, 해당 트랜잭션에 대한 변경 사항이 데이터 파일에 바로 기록되지 않는다.
2. **메모리에서의 변경:** 트랜잭션 수행 중에 이루어진 데이터베이스의 변경은 먼저 메모리에 기록되며, 이는 빠르게 이루어진다.
3. **WAL 로그 기록:** 메모리에 기록된 변경 사항은 동시에 WAL 로그에 기록된다. 이 로그는 디스크에 순차적으로 쓰여지는데, 이를 'Write-Ahead Logging'이라고 한다.
4. **트랜잭션 커밋:** 트랜잭션이 성공적으로 완료되면, 해당 트랜잭션을 커밋한다.
5. **디스크에 변경사항 반영:** WAL 로그를 사용하여 변경 사항이 디스크에 기록된다. 디스크에는 실제 데이터 파일이 아니라 WAL 로그만 순차적으로 기록된다.
6. **디스크에 데이터 반영:** WAL 로그에 대한 기록이 디스크에 안정적으로 기록되면, 해당 변경 사항이 데이터 파일에 적용된다.

## **왜 필요한가?**
1. **내구성 보장:** WAL은 데이터베이스의 내구성을 보장한다. 트랜잭션이 커밋되면, 해당 트랜잭션의 변경 사항이 디스크에 안전하게 기록되기 때문에 시스템 장애가 발생하더라도 데이터를 복구할 수 있다.
2. **성능 향상:** 변경 사항을 메모리에 먼저 기록하고 WAL 로그를 사용하여 디스크에 비동기적으로 기록함으로써, 데이터베이스의 성능을 향상시킬 수 있다. 디스크에 순차적으로 기록되기 때문에 랜덤 I/O를 최소화할 수 있다.
3. **복구 기능:** WAL은 데이터베이스의 복구 기능을 지원한다. 시스템이 예기치 않게 중단되면, WAL을 사용하여 마지막으로 성공적으로 완료된 트랜잭션까지의 변경 사항을 재적용하여 데이터베이스를 복구할 수 있다.

# Ref
- https://bourbonkk.tistory.com/86

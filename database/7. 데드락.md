# DeadLock
DeadLock(교착상태)란, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말한다. 나의 경우는 트랜잭션간의 교착상태를 의미한다. 두개의 트랜잭션간에 각각의 트랜잭션이 가지고 있는 리소스의 Lock을 획득하려고 할 때 발생한다.

# 예방 기법

대표적인 예방 기법은 아래와 같다.

- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock(잠금)한다.
    - 필요한 모든 데이터를 Lock(잠금)해야 하므로 병행성이 떨어진다.
- SET LOCK_TIMEOUT문을 통해 일정 시간이 지나면 쿼리를 취소한다.
    - 기존의 교착상태인 데이터가 있다면, 그 데이터에 접근하는 쿼리만 취소한다.
    - 즉, 근본적인 해결책이 될 수 없다.

# 회피 기법

**회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 활용해서 교착상태가 일어나지 않도록 회피하는 방법**이다. 예방 기법의 단점 때문에 실제로는 회피 기법이 많이 사용된다.

회피 기법의 종류는 크게 2가지가 있다.

- Wait-Die 방식
    - 트랜잭션 A가 트랜잭션 B에 의해 잠금된 데이터를 요청할 때 트랜잭션 A이 먼저 들어온 트랜잭션이라면 대기(Wait)한다.
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면, 포기(Die)하고 나중에 다시 요청한다.
- Wound-Wait 방식
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 데이터를 선점(Wound)한다.
    - 반면, 트랜잭션A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다.

# 낙관적 병행 제어 기법

낙관적 병행 제어 기법은 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백(Rollback)하는 방법이다.

즉, 낙관적 병행 제어 기법은 **판독->확인->기록** 단계를 따른다. **확인 단계**를 성공적으로 거친 트랜잭션만  **기록 단계**를 수행할 수 있다.

# 빈도 줄이기

교착상태의 빈도를 낮추는 방법은 아래와 같다.

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. (위에서는 트랜잭션 1은 B->A 순, 트랜잭션 2는 A->B순으로 접근했다.)
- 읽기 잠금 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 테이블 단위의 Lock(잠금)을 획득해 갱신을 직렬화한다. (테이블의 복수행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 자주 발생하기 때문)
- Index 설계 (Update시 Index를 타지 않으면 테이블 전체에 Lock이 걸릴 수 있다.)
- Isolation level(고립 수준)을 낮춘다. (서비스 검토 필요)

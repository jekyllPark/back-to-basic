# HotSpot JVM
HotSpot JVM은 말 그대로 Hot 한 Spot을 찾아 해당 부분에서 JIT 컴파일러를 사용하는 방법입니다.

내부적으로 프로파일링을 통해 핫스팟을 찾아내어 해당 부분에 대한 네이티브 코드를 생성합니다.

이 때 네이티브 코드를 생성하는 방법에서 아래 두 가지 방법이 존재합니다.

## Client

클라이언트 모드에서 동작하는 컴파일러는 주로 프로그램의 **시작 시간을 최소화하는데 집중**합니다. 크게 세 단계로 이루어져있습니다.

또한 32bit 시스템에서만 활용할 수 있습니다.

1. 바이트 코드를 해석해서 최적화를 쉽게하기 위해 HIR이라는 정적 바이트 코드 표현을 만든다.
2. HIR로부터 플랫폼에 종속적인 중간표현식을 만든다.
3. LIR을 사용하여 기계어를 생성한다.

클라이언트 모드 JIT의 특징은 바이트 코드로부터 최대한 많은 정보를 뽑아 실제 동작하는 코드 블럭에 대한 최적화에 집중하는 것입니다.

## Server

서버의 JIT은 부분적인 코드 실행보다는 **전체적인 성능 최적화에 관점**을 둡니다.

1. 일반적 컴파일러 최적화 기술들을 이용해 코드를 최적화합니다.
    1. Dead Code Elimiation
    2. Loop Invariants Hoisting
    3. Common Subexpression Elimination
    4. Constant propagation
    5. Global Code Motion 등
2. 자바에 최적화된 최적화를 진행합니다.
    1. Null Check 삭제, 배열의 Range Check 삭제 등

추후 참고(https://blog.naver.com/2feelus/220738480797)

JIT 컴파일러는 기본적으로 실행 중에 컴파일을 합니다.

좋은 성능을 내는데 그 이유는 기계어로 변환된 코드를 캐시에 저장시켜 재사용 시 컴파일을 다시 하지 않아도 되기 때문입니다.

하지만 JVM의 캐시 공간은 매우 작기 때문에 모든 코드들을 캐시하는 건 아닙니다.

JVM은 내부에서 **자주 수행되는 코드들을 선별하여 캐시** 공간에 넣어둡니다.

실제로 JVM의 JIT 컴파일러 내부에는 2가지 컴파일러인 C1 / C2 컴파일러가 있습니다.

C1 컴파일러는 가능한 빠른 실행 속도를 위해 코드를 빠르게 최적화 하고 컴파일 합니다 (client)

C2 컴파일러는 C1에 비해 컴파일 시간이 상대적으로 길지만 더 높은 수준의 최적화를 지원합니다. (server)

JVM은 코드들의 수행 빈도와 복잡도에 따라 총 4가지 레벨로 분류하여 코드를 수행하는데,

> C1 compiler : 1~3 level compilation
> 
> 
> C2 compiler : 4 level compilation
> 

## Tiered Compilation

티어드 컴파일은 자바 7부터 릴리즈되어 자바 8에서는 기본으로 사용할 수 있습니다.

- Level 0 - Interpreted Code: JVM은 초기에 모든 코드를 인터프리터를 통해 실행한다. 이 단계는 앞서 살펴본것과 같이, 컴파일된 기계어를 실행하는 것보다 성능이 낮다.
- Level 1 - Simple C1 Compiled Code: Level 1 은 JIT 컴파일러가 단순하다고 판단한 메서드에 대해 사용된다. 여기서 컴파일된 메서드들은 복잡도가 낮아, C2 컴파일러로 컴파일한다고 하더라도 성능이 향상되지 않는다. 따라서 추가적인 최적화가 필요 없으므로 프로파일링 정보도 수집하지 않는다.
- Level 2 - Limited C1 Compiled Code: 제한된 수준으로 프로파일링과 최적화를 진행하는 단계이다. C2 컴파일러 큐가 꽉 찬경우 실행된다.
- Level 3 - Full C1 Compiled Code: 최대 수준으로 프로파일링과 최적화를 진행한다. 즉 일반적인 상황에서 수행된다.
- Level 4 - C2 Compiled Code: 애플리케이션의 장기적인 성능을 위해 C2 컴파일러가 최적화를 수행한다. Level 4에서 최적화된 코드는 완전히 최적화 되었다고 간주되어, 더이상 프로파일링 정보를 수집하지 않는다.

# 스레드가 많으면 성능에 좋을까?

여러 관점에서 생각을 해야 하는데, 

## 첫 째로는 어플리케이션의 동작 순서에 따라 다르다.

만약 어플리케이션의 특정 로직이 **순차적으로 실행되어야 하는 특징**을 갖는다면 스레드의 수는 한계가 있을 것이다. 

여기서 스레드 수를 더 늘려봤자 순차 실행에 필요한 개수 이상의 스레드를 사용하게 되면 별다른 이점이 없기 때문이다.

## 둘 째로는 **컨텍스트 스위칭**과 관련이 있다.

프로세스나 스레드나 방금까지 실행했던 컨텍스트를 저장하는 주체는 운영체제이기 때문에,

운영체제는 프로세스를 관리하는 프로세스 제어 블록을 갖고 있다.

프로세스가 대기 혹은 준비상태로 변하며 다시 실행될 때 저장한 데이터를 불러오는데 프로세스는 상당히 무겁다.

즉, 프로세스끼리는 공유한 자원이 없기에 운영체제 입장에선 한 번에 많은 데이터를 PCB에 저장하고 다시 프로세스를 변경해야 하기 때문에 작업이 무거워진다.

그렇다면 스레드의 입장에선 어떨까?

스레드는 독립적인 stack 영역을 제외한 코드 / 데이타 / 힙 영역을 부모 프로세스에서 공유하고 있다.

따라서 운영체제 입장에선 스위칭이 일어날 때마다 모든 데이터를 저장할 필요가 없으므로, 컨텍스트 스위칭 비용이 줄어들게 된다.

코어에 올라간 **스레드가 다른 스레드로 변경되는 동안** 애플리케이션의 코드는 실행되지 않는다.

즉, **CPU가 대기하는 CPU Time**이 발생한다.

이 **CPU Time은 멀티 스레딩으로 동작하기 위해 필요하고 이를 Overhead**라고 한다.

공유자원이 많은 스레드는 컨텍스트 비용이 적지만, 컨텍스트 스위칭을 하게 되면 CPU의 대기 시간이 발생한다.

서버의 코어 수는 고정되어 있고, 스레드 수를 게속 늘리게 된다면 어느 순간 Overhead에 의해 성능면에서도 한계에 부딪히게 된다.

## 셋 째, **CPU Bound / IO Bound의 관점**이다.

각 바운드에 대해 알기 전 Burst라는 단어를 알아야 한다.

**Burst는 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것**이다.

CPU Burst는 프로세스가 **CPU에서 한 번에 연속적으로 실행되는 시간**이다.

I/O Burst는 프로세스가 **I/O 작업을 요청하고 그 ‘결과’를 기다리는 시간**이다.

프로세스는 CPU Burst와 IO Burst의 연속이다.

즉, 처음에 메모리에 올라갈 때 CPU Burst, 중간 중간 CPU - IO를 반복하다가 프로세스가 종료시엔 다시 CPU Burst로 끝나게 된다.

CPU Burst가 일어나는 예시를 들자면, 비디오 렌더링이나 문자열 파싱 등과 같은 연산 작업이 많이 발생하는 경우이다.

IO bound는 IO Burst가 많은 프로세스이며 일반적으로 백엔드 API 서버를 예시로 클라이언트로부터 리퀘스트를 받고 써드파티 DB 혹은 캐시 서버에 Data를 요청한다 가정하면 여기서 **DB 서버와 캐시 서버에 요청하는 것이 API 서버에서의 IO 작업**이다.

예를 들어 싱글 코어, CPU Bound를 예시로 들어보자.

프로세스에 약 4개의 스레드가 있다고 가정한다면, 코어가 한 개이므로 각 코어에 4개의 스레드가 매핑된다.

CPU Bound 프로세스는 실행 시간이 길다.

하지만 멀티 태스킹 조건에 의해 각 코어 내부의 스레드들은 매우 빠른 속도로 컨텍스트 스위칭을 하게 된다.

일반적으로 CPU Time에서는 컨텍스트 스위칭 시간도 포함되므로 불필요한 오버헤드가 발생된다.

왜냐면 스레드는 각 1개의 코어에 매핑되기 때문이다.

그렇기에 코어와 스레드가 1:1 매핑되어 스레드들간의 컨텍스트 스위칭이 발생하지 않게 되고 결과적으로는 불필요한 오버헤드가 발생하지 않게 된다.

IO Bound의 경우에는 CPU가 대기하는 시간이 많기 때문에 CPU Bound의 경우와 다르게 코어 수보다 몇 배를 선정하여 CPU의 오버헤드가 늘어나더라도 코어들을 효율적으로 쓸 수 있어 성능면에서 이점이 있을 수 있다.

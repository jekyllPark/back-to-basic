# 구성도
![spring_request_process drawio](https://github.com/jekyllPark/back-to-basic/assets/114489012/22d50ca9-7c05-40ee-aa49-5fea7314b859)

계속 정리

1. 최초 사용자가 http request를 날린다.
2. 서블릿 컨테이너 내부에서 필터를 거쳐 디스패쳐 서블릿으로 전달된다.
3. 디스패쳐 서블릿에서 인터셉터를 거쳐 핸들러 매핑 어노테이션을 통해 적절한 핸들러를 찾는다.
4. 3번에서 찾은 핸들러를 핸들러 어댑터를 통해서 해당 request를 처리할 컨트롤러에 전달이 된다.
5. 5.서비스 레이어에서 save를 호출할 경우에 jpaRepository의 구현체인 simpleJpaRepository를 통해 persist를 호출한다.
6. persist를 호출하면 persistEvent가 발행되어 해당 이벤트를 통해 session 내부에서 각 이벤트 리스너 그룹 중 persistEventListener를 통해 onPersist가 실행된다.
7. onPersist가 실행되면, entityEntryGroup에 해당 entity가 저장되고, actionqueue에 insert sql이 저장된다.
8. 트랜잭션이 종료되면 actionQueue에 있는 sql이 실행되면서 db에 실제로 액세스하여 쿼리를 실행한다.

---

세이브 맨~

1. 사용자가 추상화 되어있는 Repository에서 save 호출 
2. → SimpleJpaRepository에서 save호출
3. 여기서 EntityManager 인터페이스의 persist 호출
4. 이놈 em의 구현체인 SessionImpl을 통해 persist발동 → firePersist
5. `fastSessionServices.eventListenerGroup_PERSIST.fireEventOnEachListener( event, PersistEventListener::onPersist );`
6. 5번을 통해 abstractEvent 상속받은 persistEvent 이벤트 발행함
7. 발행된 이벤트를 defaultPersistEventListener가 수신해서 아래 작업
8. entityEntryContext에 addEntry됨
9. ActionQueue에 addInsertAction됨
10. 트랜잭션 끝나면서 플러쉬 되면 플러시 이벤트 발행하고
11. 영속성 컨텍스트 비워주고 actionQueue에 있는 sql 날려줌

- 키워드
    - AbstractEvent
        - PersistEvent
        - PersistEventListener
    - DefaultPersistEventListner

애플리케이션 라이프 사이클 추가

인터셉터랑 로우레벨 추가까지

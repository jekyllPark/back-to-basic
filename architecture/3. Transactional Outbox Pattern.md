# 개요

이벤트로 분리된 애플리케이션 환경에서는 메시지 발행과 트랜잭션 커밋 시점에 대한 문제가 생긴다. 

애플리케이션 로직 상 트랜잭션이 완료되기 전에 이벤트 메시지를 발행하게 되는데, 그러면 이후 비즈니스 로직에서 예외가 발생하거나 DB에 쿼리를 날린 이후 특정한 이유 때문에 예외가 발생해 롤백이 될 수 있다. 
이 경우 트랜잭션이 성공하지 않았는데 메시지가 발행이 되는 경우가 생길 수 있고 시스템의 안정성이 보장되지 못한다.

이러한 이유로 분산 트랜잭션의 문제점과 이를 해결하는 방법 중 하나인 아웃 박스 패턴에 대해 알아보자.

# 2PC

보통 우리가 개발하는 서비스는 DB를 업데이트 하는 트랜잭션과 함께 메시지를 발행한다. 이 때 DB를 업데이트와 메시지 전송을 한 트랜잭션으로 묶지 않는다면, 하나의 애플리케이션 서비스 내에서 원자적으로 수행되지 않는다면 시스템이 실패할 경우 문제가 발생하게 된다.

기존에는 이 원자성을 보장하기 위해 분산 트랜잭션을 사용했다.

분산 트랜잭션은 2PC(2-phase-commit)을 이용하여 트랜잭션 참여자가 커밋 혹은 롤백을 할 수 있도록 원자성을 보장하는 방법이다.
분산 트랜잭션을 단일 DB에 비해 성능 저하가 발생할 수 있다. 
또한 동기 IPC(Inter-Process Communication) 형태라 가용성이 떨어지는 문제가 있다.
현대의 아키텍처는 일관성보다 가용성을 우선시하고 있다.
이러한 이유로 분산 트랜잭션 방식은 현대 어플리케이션과 맞지 않으며 최신 메시지 브로커(Kafka)는 기능 자체를 지원하지 않는다.

# 아웃박스 패턴

우리는 다음 2가지를 보장해야 한다.

1. 데이터베이스 트랜잭션이 커밋되면 메시지가 발행되어야 하며, 롤백된다면 메시지를 발행하지 않아야 한다.
2. 메시지 서비스는 보낸 순서대로 브로커로 보내야 한다.

이 문제를 해결하기 위한 방법으로 우리는 DB를 업데이트 하는 트랜잭션의 일부로 데이터베이스에 메시지를 저장하는 방법이 있다.

그런 다음 별도의 프로세스가 저장된 이벤트를 읽어 메시지 브로커에 전송하는 것이다. 이러한 방법을 Outbox Pattern 이라고 한다.

애플리케이션은 데이터베이스의 outbox 테이블에 메시지 내용을 저장하고, 다른 애플리케이션이나 프로세스는 outbox 테이블에서 데이터를 읽고 해당 데이터를 사용하며 작업을 수행할 수 있다.

실패 시 완료될 때까지 다시 시도할 수 있다. 따라서 oubox 패턴은 적어도 한 번 이상 (at-last once) 메시지가 성공적으로 전송되었는지 확인할 수 있다.

여기서 outbox는 전송되지 않았거나 전송에 실패한 메시지들이 모여있는 보관함이라는 뜻이다.

아웃박스 패턴을 구현하는 방법 중에는 대표적으로 두 가지 패턴이 있다.

1. 폴링 발행기 패턴
    1. RDBMS를 사용하는 애플리케이션에서 outbox 테이블에 삽입된 메시지를 발행하는 간단한 방법으로 테이블을 폴링해서 미발행된 메시지를 조회하는 것이다. 메시지 릴레이는 이렇게 조회한 메시지를 하나 씩 각자의 목적지 채널로 보내서 메시지 브로커에 발행한다. 그리고 나중에 outbox 테이블에서 메시지를 삭제한다.
    2. DB 폴링은 규모가 작을 경우 쓸 수 있는 쉬운 방법이다. 하지만 DB를 자주 폴링하면 비용이 발생하고 NoSQL DB는 쿼리 능력에 따라 사용 가능 여부가 결정된다.
    ![image](https://github.com/jekyllPark/back-to-basic/assets/114489012/05d70979-e1c6-4527-b082-f05c2d41da0a)
    
2. 트랜잭션 로그 테일링 패턴
    1. 메시지 릴레이로 DB 트랜잭션 로그를 테일링 하는 방법입니다.
    애플리케이션에서 커밋된 업데이트는 각 DB의 트랜잭션 로그 항목으로 남는다. 트랜잭션 로그 마이너로 트랜잭션 로그를 읽어 변경분을 하나씩 메시지로 메시지 브로커에 발행하는 방법이다.
    
    ![image](https://github.com/jekyllPark/back-to-basic/assets/114489012/1d119365-49aa-48b6-a6fd-8472f79f60f7)

    
    트랜잭션 로그 마이너는 트랜잭션 로그 항목을 읽고 삽입된 메시지에 대응되는 각 로그 항목을 메시지로 전환하여 메시지 브로커에 발행한다. RDBMS의 outbox 테이블에 출력된 메시지 또는 NoSQL DB에 레코드에 추가된 메시지를 발행할 수 있다.
    
    MySQL의 경우, mysqlbinlog 등을 활용하여 변경사항을 읽어 구현할 수 있다. 
    구현 난이도가 높아 관련 툴을 사용하는 경우가 많다.
    관련 툴로는 Debezium, Linkedin Databus, DynamoDB Streams 등이 있다.
    
    Kafka Connect를 통해 아웃박스 패턴을 구현하는 방법도 있다.
    
    Kafka-Connect는 Kafka 브로커 외에 별도의 서비스로 실행된다.
    Kafka-Connect는 런타임 시점에서 데이터베이스의 변경사항을 캡쳐하기 위해 Debezium 커넥터가 배포되며, Debezium 커넥터는 outbox 테이블에서 데이터베이스 트랜잭션 로그(write ahead log)를 추적하고 사용자 정의 커넥터에 의해 정의된 토픽에 메시지를 발행한다.
    
     ![image](https://github.com/jekyllPark/back-to-basic/assets/114489012/ec612ae2-f105-4c94-9bf4-fab040f599f1)

    이 방법은 적어도 한 번 전달을 보장한다. 
    커넥터가 다운되고 시작 될 때 동일한 이벤트를 여러 번 게시할 때가 있는데, 따라서 consumer는 멱등성 상태여야 하며 중복 이벤트가 다시 처리되지 않도록 해야한다.
    이와 같이 로그의 변경된 데이터를 감지하는 작업을 CDC(Change Data Capture) 라고 한다.
    Debezium MySQL Connector는 binlog를 읽어 INSERT, UPDATE, DELETE 연산에 대한 변경 이벤트를 만들어 Kafka 토픽으로 전송해준다. 
    따라서 DB에서 수행된 모든 이벤트가 안정적으로 수집되고 이벤트 발행 시 정확한 순서가 보장된다.
# Ref
https://velog.io/@eastperson/Transaction-Outbox-Pattern-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0
